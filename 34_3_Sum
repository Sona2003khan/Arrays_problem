import java.util.*;

class ArrayHard2_3_sum {
    
    public static List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums); // O(n log n)
        int n = nums.length;
        List<List<Integer>> ans = new ArrayList<>();

        for(int i = 0; i < n; i++){
            if(i > 0 && nums[i]==nums[i-1]){
                i++; // Note: This should be 'continue;' instead of 'i++;' to skip duplicates
            }
            int j = i + 1;
            int k=n-1;

            while(j < k){
                int sum = nums[i]+nums[j]+nums[k];
                if(sum == 0){
                    ans.add(Arrays.asList(nums[i],nums[j],nums[k]));

                    while(j < k && nums[j]==nums[j+1]) { j++; }
                    while(j < k && nums[k]==nums[k-1]) { k--; }
                }

                if(sum < 0){
                    j++;
                }
                else{
                    k--;
                }

            }
        }
        return ans;
    }

    public static List<List<Integer>> threeSumUsingComplement(int[] nums) {

        int n = nums.length;
        Arrays.sort(nums); // O(n log n)
        Set<List<Integer>> list = new HashSet<>();
        
        for(int i=0;i<n; i++){
            Set<Integer> map = new HashSet<>();
            int target = -nums[i];

            for(int j=i+1;j<n;j++){
                int complement = target - nums[j];
                if(map.contains(complement)){
                    list.add(Arrays.asList(nums[i],nums[j],complement));
                }
                map.add(nums[j]);
            }
        }
        return new ArrayList<>(list);
    }

    public static void main(String[] args) {
        int nums[] = {-1,0,1,2,-1,-4};
        List<List<Integer>> result = threeSum(nums);
        System.out.println("using two pointer "+result);

        List<List<Integer>> result2 = threeSumUsingComplement(nums);
        System.out.println("using complement "+result2);
    }
}

/*
Time Complexity Analysis:

1. threeSum (Two Pointer approach):
   - Sorting: O(n log n)
   - Outer loop: O(n)
   - Inner while loop (two pointers) scans the rest of the array once for each i: O(n)
   => Total: O(n^2)

2. threeSumUsingComplement (Using HashSet):
   - Sorting: O(n log n)
   - Outer loop: O(n)
   - Inner loop with HashSet operations: O(1) average, iterates O(n) times
   => Total: O(n^2) on average, worst case O(n^2) for adding/checking in HashSet

Space Complexity:
- threeSum: O(1) extra space (excluding output)
- threeSumUsingComplement: O(n) extra space for HashSet per iteration + O(n) for output
*/
